import os
import json
import hashlib
from typing import Dict, Any, List
from datetime import datetime

class ProjectFolderManager:
    """Manages organized project folder structure for artifacts."""
    
    def __init__(self, base_artifacts_dir: str = "artifacts"):
        self.base_artifacts_dir = base_artifacts_dir
        self.projects_metadata_file = os.path.join(base_artifacts_dir, ".projects_metadata.json")
        
        # Ensure base directory exists
        os.makedirs(base_artifacts_dir, exist_ok=True)
    
    def get_project_folder(self, task: Dict[str, Any], objective: str = None) -> str:
        """Get or create appropriate project folder for a task."""
        
        # Extract project information
        project_id = task.get('subtask_data', {}).get('project_id')
        objective = objective or task.get('subtask_data', {}).get('objective', 'Unknown Project')
        
        # Generate project folder name
        project_folder_name = self._generate_project_folder_name(objective, project_id)
        project_folder_path = os.path.join(self.base_artifacts_dir, project_folder_name)
        
        # Create project folder if it doesn't exist
        if not os.path.exists(project_folder_path):
            self._create_project_folder(project_folder_path, objective, project_id, task)
        
        return project_folder_path
    
    def _generate_project_folder_name(self, objective: str, project_id: str = None) -> str:
        """Generate a clean, descriptive folder name."""
        
        # Clean the objective for use as folder name
        clean_objective = self._clean_for_filename(objective)
        
        # Truncate if too long
        if len(clean_objective) > 50:
            clean_objective = clean_objective[:47] + "..."
        
        # Add a short hash for uniqueness if needed
        if project_id:
            short_hash = hashlib.md5(project_id.encode()).hexdigest()[:6]
            folder_name = f"{clean_objective}_{short_hash}"
        else:
            folder_name = clean_objective
        
        return folder_name
    
    def _clean_for_filename(self, text: str) -> str:
        """Clean text for use in filename/folder name."""
        
        # Convert to lowercase and replace spaces with underscores
        clean = text.lower()
        
        # Remove or replace problematic characters
        clean = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in clean)
        
        # Replace multiple spaces/underscores with single underscore
        clean = '_'.join(clean.split())
        
        # Remove leading/trailing underscores
        clean = clean.strip('_')
        
        # Ensure it's not empty
        if not clean:
            clean = "unnamed_project"
        
        return clean
    
    def _create_project_folder(self, project_folder_path: str, objective: str, project_id: str, task: Dict[str, Any]):
        """Create project folder with initial structure."""
        
        # Create the main folder
        os.makedirs(project_folder_path, exist_ok=True)
        
        # Create README.md
        readme_path = os.path.join(project_folder_path, "README.md")
        self._create_project_readme(readme_path, objective, project_id)
        
        # Update projects metadata
        self._update_projects_metadata(project_folder_path, objective, project_id, task)
        
        print(f"[PROJECT] Created folder: {os.path.basename(project_folder_path)}")
    
    def _create_project_readme(self, readme_path: str, objective: str, project_id: str):
        """Create a README.md for the project."""
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        readme_content = f"""# {objective}

**Generated by AI Agent Framework**

## Project Information
- **Objective**: {objective}
- **Project ID**: {project_id}
- **Created**: {timestamp}
- **Generator**: Hierarchical Multi-Agent System

## Project Structure
This folder contains all artifacts generated for this project:
- Source code files
- Documentation
- Configuration files
- Assets and resources

## How to Run
Check individual files for specific run instructions. Most projects include:
```bash
# For Python projects
python main.py

# For JavaScript projects  
open index.html
# or
node main.js

# For other languages
# See specific file headers for instructions
```

## Generated Files
Files in this project are automatically generated and organized by domain:
- **Code files**: Main implementation
- **Documentation**: Supporting docs and guides
- **Assets**: Images, data files, configurations

---
*This project was created autonomously by an AI agent framework that breaks down objectives into manageable tasks and implements them with domain-specific expertise.*
"""
        
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme_content)
    
    def _update_projects_metadata(self, project_folder_path: str, objective: str, project_id: str, task: Dict[str, Any]):
        """Update metadata about all projects."""
        
        # Load existing metadata
        metadata = self._load_projects_metadata()
        
        folder_name = os.path.basename(project_folder_path)
        
        # Add/update project info
        metadata[folder_name] = {
            'objective': objective,
            'project_id': project_id,
            'folder_path': project_folder_path,
            'created_at': datetime.now().isoformat(),
            'last_updated': datetime.now().isoformat(),
            'file_count': 1,  # Start with README
            'domains': [],
            'languages': []
        }
        
        # Save metadata
        self._save_projects_metadata(metadata)
    
    def _load_projects_metadata(self) -> Dict[str, Any]:
        """Load projects metadata from file."""
        
        if os.path.exists(self.projects_metadata_file):
            try:
                with open(self.projects_metadata_file, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def _save_projects_metadata(self, metadata: Dict[str, Any]):
        """Save projects metadata to file."""
        
        try:
            with open(self.projects_metadata_file, 'w') as f:
                json.dump(metadata, f, indent=2)
        except Exception as e:
            print(f"[PROJECT] Warning: Could not save metadata: {e}")
    
    def save_artifact_to_project(self, task: Dict[str, Any], solution: str, domain: str, language: str = None, objective: str = None) -> str:
        """Save an artifact to the appropriate project folder."""
        
        # Get project folder
        project_folder = self.get_project_folder(task, objective)
        
        # Generate filename
        filename = self._generate_artifact_filename(task, domain, language)
        filepath = os.path.join(project_folder, filename)
        
        # Ensure no duplicates
        filepath = self._ensure_unique_filepath(filepath)
        
        # Save the artifact
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                # Add header
                f.write(self._generate_file_header(task, domain, language))
                f.write('\n\n')
                f.write(solution)
            
            # Update project metadata
            self._update_project_file_count(project_folder, domain, language)
            
            # Check if we should generate an entry point
            self._maybe_generate_entry_point(project_folder, domain, language, objective)
            
            print(f"[PROJECT] Saved: {os.path.basename(project_folder)}/{filename}")
            return filepath
            
        except Exception as e:
            print(f"[PROJECT] Error saving artifact: {e}")
            return ""
    
    def _maybe_generate_entry_point(self, project_folder: str, domain: str, language: str, objective: str):
        """Generate entry point files if appropriate."""
        
        # Get list of existing files
        existing_files = []
        try:
            existing_files = [f for f in os.listdir(project_folder) 
                            if f.endswith(('.js', '.py', '.html', '.css')) and not f.startswith('.')]
        except:
            return
        
        # Count files by type
        js_files = [f for f in existing_files if f.endswith('.js')]
        py_files = [f for f in existing_files if f.endswith('.py')]
        html_files = [f for f in existing_files if f.endswith('.html')]
        
        # Generate entry points based on project characteristics
        if language == 'javascript' and len(js_files) >= 2 and not html_files:
            self._generate_html_entry_point(project_folder, js_files, objective)
        
        elif language == 'python' and len(py_files) >= 2 and not any('main' in f.lower() for f in py_files):
            self._generate_python_main(project_folder, py_files, objective)
        
        elif domain == 'game' and len(existing_files) >= 2:
            if language == 'javascript':
                self._generate_game_html_entry(project_folder, js_files, objective)
            elif language == 'python':
                self._generate_game_python_main(project_folder, py_files, objective)
    
    def _generate_html_entry_point(self, project_folder: str, js_files: List[str], objective: str):
        """Generate HTML entry point for JavaScript projects."""
        
        html_path = os.path.join(project_folder, "index.html")
        if os.path.exists(html_path):
            return  # Don't overwrite existing HTML
        
        # Determine if this is a game or web app
        is_game = any(word in objective.lower() for word in ['game', 'doom', 'arcade', 'puzzle', 'player'])
        
        html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{objective}</title>
    <style>
        body {{
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }}
        
        h1 {{
            color: #4CAF50;
            text-align: center;
            margin-bottom: 20px;
        }}
        
        #gameContainer {{
            text-align: center;
            margin: 20px 0;
        }}
        
        canvas {{
            border: 2px solid #4CAF50;
            background-color: #000;
            display: block;
            margin: 0 auto;
        }}
        
        .controls {{
            margin-top: 20px;
            padding: 15px;
            background-color: #2a2a2a;
            border-radius: 8px;
            max-width: 600px;
        }}
        
        .status {{
            margin-top: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            font-family: monospace;
        }}
    </style>
</head>
<body>
    <h1>{objective}</h1>
    
    <div id="gameContainer">
        {"<canvas id='gameCanvas' width='800' height='600'></canvas>" if is_game else "<div id='appContainer'></div>"}
    </div>
    
    {"<div class='controls'>" if is_game else ""}
    {"<h3>Controls:</h3>" if is_game else ""}
    {"<p><strong>WASD or Arrow Keys:</strong> Move player</p>" if is_game else ""}
    {"<p><strong>Mouse:</strong> Look around</p>" if is_game else ""}
    {"<p><strong>Space:</strong> Action/Shoot</p>" if is_game else ""}
    {"</div>" if is_game else ""}
    
    <div class="status" id="status">
        Loading JavaScript components...
    </div>
    
    <!-- Load all JavaScript files -->"""

        # Add script tags for all JavaScript files
        for js_file in sorted(js_files):
            html_content += f'\n    <script src="{js_file}"></script>'
        
        html_content += f"""
    
    <script>
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {{
            console.log('Initializing {objective}...');
            document.getElementById('status').textContent = 'Application loaded successfully!';
            
            {"// Initialize game if canvas exists" if is_game else "// Initialize application"}
            {"const canvas = document.getElementById('gameCanvas');" if is_game else ""}
            {"if (canvas) {" if is_game else ""}
            {"    console.log('Canvas found, starting game...');" if is_game else ""}
            {"    // Game initialization code will be handled by loaded scripts" if is_game else ""}
            {"}" if is_game else ""}
        }});
        
        // Error handling
        window.addEventListener('error', function(e) {{
            document.getElementById('status').textContent = 'Error: ' + e.message;
            console.error('Application error:', e);
        }});
    </script>
</body>
</html>"""
        
        try:
            with open(html_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            print(f"[PROJECT] Generated HTML entry point: index.html")
        except Exception as e:
            print(f"[PROJECT] Error generating HTML entry point: {e}")
    
    def _generate_game_html_entry(self, project_folder: str, js_files: List[str], objective: str):
        """Generate specialized HTML entry point for games."""
        # This could be more sophisticated for different game types
        self._generate_html_entry_point(project_folder, js_files, objective)
    
    def _generate_python_main(self, project_folder: str, py_files: List[str], objective: str):
        """Generate Python main.py entry point."""
        
        main_path = os.path.join(project_folder, "main.py")
        if os.path.exists(main_path):
            return  # Don't overwrite existing main
        
        # Analyze files to determine import structure
        imports = []
        for py_file in py_files:
            if py_file != 'main.py':
                module_name = py_file.replace('.py', '')
                imports.append(module_name)
        
        main_content = f'''#!/usr/bin/env python3
"""
Main Entry Point: {objective}
Generated by AI Agent Framework
"""

import sys
import os

# Add current directory to path for local imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import project modules
'''

        for module in imports:
            # Try to guess the main class/function name
            class_name = ''.join(word.capitalize() for word in module.split('_'))
            main_content += f"# from {module} import {class_name}\n"
        
        main_content += f'''

def main():
    """Main application entry point."""
    print("Starting: {objective}")
    print("=" * 50)
    
    try:
        # Initialize and run the application
        # TODO: Call initialization functions from imported modules
        print("Application modules loaded successfully!")
        print("\\nAvailable modules:")
'''

        for module in imports:
            main_content += f'        print(f"  - {module}.py")\n'
        
        main_content += f'''
        
        print("\\nTo run specific components, modify this main.py file")
        print("or run individual module files directly.")
        
    except ImportError as e:
        print(f"Error importing modules: {{e}}")
        print("Make sure all required dependencies are installed.")
    except Exception as e:
        print(f"Application error: {{e}}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
'''
        
        try:
            with open(main_path, 'w', encoding='utf-8') as f:
                f.write(main_content)
            print(f"[PROJECT] Generated Python entry point: main.py")
        except Exception as e:
            print(f"[PROJECT] Error generating Python main: {e}")
    
    def _generate_game_python_main(self, project_folder: str, py_files: List[str], objective: str):
        """Generate specialized Python main for games."""
        # This could include game-specific initialization
        self._generate_python_main(project_folder, py_files, objective)
    
    def _generate_artifact_filename(self, task: Dict[str, Any], domain: str, language: str = None) -> str:
        """Generate appropriate filename for artifact."""
        
        # Clean task title for filename
        base_name = self._clean_for_filename(task['title'])
        
        # Determine file extension based on domain and language
        if domain in ['code', 'ui', 'data', 'game']:
            if language == 'javascript':
                extension = '.js'
            elif language == 'java':
                extension = '.java'
            elif language == 'cpp':
                extension = '.cpp'
            elif language == 'csharp':
                extension = '.cs'
            elif language == 'go':
                extension = '.go'
            elif language == 'rust':
                extension = '.rs'
            else:
                extension = '.py'  # Default to Python
        elif domain == 'creative':
            extension = '.txt'
        elif domain == 'research':
            extension = '.md'
        else:
            extension = '.py'
        
        # Handle special cases for web projects
        if language == 'javascript' and ('html' in task['title'].lower() or 'web' in task['title'].lower()):
            if 'html' in task['title'].lower():
                extension = '.html'
        
        filename = f"{base_name}{extension}"
        
        # Ensure reasonable length
        if len(filename) > 100:
            base_name = base_name[:90]
            filename = f"{base_name}{extension}"
        
        return filename
    
    def _ensure_unique_filepath(self, filepath: str) -> str:
        """Ensure filepath is unique by adding number if needed."""
        
        if not os.path.exists(filepath):
            return filepath
        
        # File exists, add number
        base, ext = os.path.splitext(filepath)
        counter = 1
        
        while os.path.exists(f"{base}_{counter}{ext}"):
            counter += 1
        
        return f"{base}_{counter}{ext}"
    
    def _generate_file_header(self, task: Dict[str, Any], domain: str, language: str = None) -> str:
        """Generate appropriate file header."""
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if domain in ['code', 'ui', 'data', 'game']:
            if language == 'javascript':
                return f"""/**
 * Task: {task['title']}
 * Description: {task['description']}
 * Domain: {domain}
 * Language: {language}
 * Generated: {timestamp}
 */"""
            else:
                return f'''"""
Task: {task['title']}
Description: {task['description']}
Domain: {domain}
Language: {language or 'python'}
Generated: {timestamp}
"""'''
        else:
            return f"""---
Task: {task['title']}
Description: {task['description']}
Domain: {domain}
Generated: {timestamp}
---"""
    
    def _update_project_file_count(self, project_folder: str, domain: str, language: str = None):
        """Update project metadata with new file."""
        
        metadata = self._load_projects_metadata()
        folder_name = os.path.basename(project_folder)
        
        if folder_name in metadata:
            project_info = metadata[folder_name]
            project_info['file_count'] = project_info.get('file_count', 0) + 1
            project_info['last_updated'] = datetime.now().isoformat()
            
            # Track domains and languages
            if domain not in project_info.get('domains', []):
                project_info.setdefault('domains', []).append(domain)
            
            if language and language not in project_info.get('languages', []):
                project_info.setdefault('languages', []).append(language)
            
            self._save_projects_metadata(metadata)
    
    def list_projects(self) -> List[Dict[str, Any]]:
        """List all projects with their metadata."""
        
        metadata = self._load_projects_metadata()
        projects = []
        
        for folder_name, info in metadata.items():
            project_info = {
                'name': folder_name,
                'objective': info.get('objective', 'Unknown'),
                'file_count': info.get('file_count', 0),
                'domains': info.get('domains', []),
                'languages': info.get('languages', []),
                'created_at': info.get('created_at', 'Unknown'),
                'last_updated': info.get('last_updated', 'Unknown'),
                'folder_path': info.get('folder_path', '')
            }
            projects.append(project_info)
        
        # Sort by last updated
        projects.sort(key=lambda x: x['last_updated'], reverse=True)
        return projects