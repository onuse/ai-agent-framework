import os
import json
import hashlib
from typing import Dict, Any, List
from datetime import datetime

class ProjectFolderManager:
    """Manages organized project folder structure for artifacts."""
    
    def __init__(self, base_artifacts_dir: str = "artifacts"):
        self.base_artifacts_dir = base_artifacts_dir
        self.projects_metadata_file = os.path.join(base_artifacts_dir, ".projects_metadata.json")
        
        # Ensure base directory exists
        os.makedirs(base_artifacts_dir, exist_ok=True)
    
    def get_project_folder(self, task: Dict[str, Any], objective: str = None) -> str:
        """Get or create appropriate project folder for a task."""
        
        # Extract project information
        project_id = task.get('subtask_data', {}).get('project_id')
        objective = objective or task.get('subtask_data', {}).get('objective', 'Unknown Project')
        
        # Generate project folder name
        project_folder_name = self._generate_project_folder_name(objective, project_id)
        project_folder_path = os.path.join(self.base_artifacts_dir, project_folder_name)
        
        # Create project folder if it doesn't exist
        if not os.path.exists(project_folder_path):
            self._create_project_folder(project_folder_path, objective, project_id, task)
        
        return project_folder_path
    
    def _generate_project_folder_name(self, objective: str, project_id: str = None) -> str:
        """Generate a clean, descriptive folder name."""
        
        # Clean the objective for use as folder name
        clean_objective = self._clean_for_filename(objective)
        
        # Truncate if too long
        if len(clean_objective) > 50:
            clean_objective = clean_objective[:47] + "..."
        
        # Add a short hash for uniqueness if needed
        if project_id:
            short_hash = hashlib.md5(project_id.encode()).hexdigest()[:6]
            folder_name = f"{clean_objective}_{short_hash}"
        else:
            folder_name = clean_objective
        
        return folder_name
    
    def _clean_for_filename(self, text: str) -> str:
        """Clean text for use in filename/folder name."""
        
        # Convert to lowercase and replace spaces with underscores
        clean = text.lower()
        
        # Remove or replace problematic characters
        clean = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in clean)
        
        # Replace multiple spaces/underscores with single underscore
        clean = '_'.join(clean.split())
        
        # Remove leading/trailing underscores
        clean = clean.strip('_')
        
        # Ensure it's not empty
        if not clean:
            clean = "unnamed_project"
        
        return clean
    
    def _create_project_folder(self, project_folder_path: str, objective: str, project_id: str, task: Dict[str, Any]):
        """Create project folder with initial structure."""
        
        # Create the main folder
        os.makedirs(project_folder_path, exist_ok=True)
        
        # Create README.md
        readme_path = os.path.join(project_folder_path, "README.md")
        self._create_project_readme(readme_path, objective, project_id)
        
        # Update projects metadata
        self._update_projects_metadata(project_folder_path, objective, project_id, task)
        
        print(f"[PROJECT] Created folder: {os.path.basename(project_folder_path)}")
    
    def _create_project_readme(self, readme_path: str, objective: str, project_id: str):
        """Create a README.md for the project."""
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        readme_content = f"""# {objective}

**Generated by AI Agent Framework**

## Project Information
- **Objective**: {objective}
- **Project ID**: {project_id}
- **Created**: {timestamp}
- **Generator**: Hierarchical Multi-Agent System

## Project Structure
This folder contains all artifacts generated for this project:
- Source code files
- Documentation
- Configuration files
- Assets and resources

## How to Run
Check individual files for specific run instructions. Most projects include:
```bash
# For Python projects
python main.py

# For JavaScript projects  
open index.html
# or
node main.js

# For other languages
# See specific file headers for instructions
```

## Generated Files
Files in this project are automatically generated and organized by domain:
- **Code files**: Main implementation
- **Documentation**: Supporting docs and guides
- **Assets**: Images, data files, configurations

---
*This project was created autonomously by an AI agent framework that breaks down objectives into manageable tasks and implements them with domain-specific expertise.*
"""
        
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme_content)
    
    def _update_projects_metadata(self, project_folder_path: str, objective: str, project_id: str, task: Dict[str, Any]):
        """Update metadata about all projects."""
        
        # Load existing metadata
        metadata = self._load_projects_metadata()
        
        folder_name = os.path.basename(project_folder_path)
        
        # Add/update project info
        metadata[folder_name] = {
            'objective': objective,
            'project_id': project_id,
            'folder_path': project_folder_path,
            'created_at': datetime.now().isoformat(),
            'last_updated': datetime.now().isoformat(),
            'file_count': 1,  # Start with README
            'domains': [],
            'languages': []
        }
        
        # Save metadata
        self._save_projects_metadata(metadata)
    
    def _load_projects_metadata(self) -> Dict[str, Any]:
        """Load projects metadata from file."""
        
        if os.path.exists(self.projects_metadata_file):
            try:
                with open(self.projects_metadata_file, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def _save_projects_metadata(self, metadata: Dict[str, Any]):
        """Save projects metadata to file."""
        
        try:
            with open(self.projects_metadata_file, 'w') as f:
                json.dump(metadata, f, indent=2)
        except Exception as e:
            print(f"[PROJECT] Warning: Could not save metadata: {e}")
    
    def save_artifact_to_project(self, task: Dict[str, Any], solution: str, domain: str, language: str = None, objective: str = None) -> str:
        """Save an artifact to the appropriate project folder."""
        
        # Get project folder
        project_folder = self.get_project_folder(task, objective)
        
        # Generate filename
        filename = self._generate_artifact_filename(task, domain, language)
        filepath = os.path.join(project_folder, filename)
        
        # Ensure no duplicates
        filepath = self._ensure_unique_filepath(filepath)
        
        # Save the artifact
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                # Add header
                f.write(self._generate_file_header(task, domain, language))
                f.write('\n\n')
                f.write(solution)
            
            # Update project metadata
            self._update_project_file_count(project_folder, domain, language)
            
            print(f"[PROJECT] Saved: {os.path.basename(project_folder)}/{filename}")
            return filepath
            
        except Exception as e:
            print(f"[PROJECT] Error saving artifact: {e}")
            return ""
    
    def _generate_artifact_filename(self, task: Dict[str, Any], domain: str, language: str = None) -> str:
        """Generate appropriate filename for artifact."""
        
        # Clean task title for filename
        base_name = self._clean_for_filename(task['title'])
        
        # Determine file extension based on domain and language
        if domain in ['code', 'ui', 'data', 'game']:
            if language == 'javascript':
                extension = '.js'
            elif language == 'java':
                extension = '.java'
            elif language == 'cpp':
                extension = '.cpp'
            elif language == 'csharp':
                extension = '.cs'
            elif language == 'go':
                extension = '.go'
            elif language == 'rust':
                extension = '.rs'
            else:
                extension = '.py'  # Default to Python
        elif domain == 'creative':
            extension = '.txt'
        elif domain == 'research':
            extension = '.md'
        else:
            extension = '.py'
        
        # Handle special cases for web projects
        if language == 'javascript' and ('html' in task['title'].lower() or 'web' in task['title'].lower()):
            if 'html' in task['title'].lower():
                extension = '.html'
        
        filename = f"{base_name}{extension}"
        
        # Ensure reasonable length
        if len(filename) > 100:
            base_name = base_name[:90]
            filename = f"{base_name}{extension}"
        
        return filename
    
    def _ensure_unique_filepath(self, filepath: str) -> str:
        """Ensure filepath is unique by adding number if needed."""
        
        if not os.path.exists(filepath):
            return filepath
        
        # File exists, add number
        base, ext = os.path.splitext(filepath)
        counter = 1
        
        while os.path.exists(f"{base}_{counter}{ext}"):
            counter += 1
        
        return f"{base}_{counter}{ext}"
    
    def _generate_file_header(self, task: Dict[str, Any], domain: str, language: str = None) -> str:
        """Generate appropriate file header."""
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if domain in ['code', 'ui', 'data', 'game']:
            if language == 'javascript':
                return f"""/**
 * Task: {task['title']}
 * Description: {task['description']}
 * Domain: {domain}
 * Language: {language}
 * Generated: {timestamp}
 */"""
            else:
                return f'''"""
Task: {task['title']}
Description: {task['description']}
Domain: {domain}
Language: {language or 'python'}
Generated: {timestamp}
"""'''
        else:
            return f"""---
Task: {task['title']}
Description: {task['description']}
Domain: {domain}
Generated: {timestamp}
---"""
    
    def _update_project_file_count(self, project_folder: str, domain: str, language: str = None):
        """Update project metadata with new file."""
        
        metadata = self._load_projects_metadata()
        folder_name = os.path.basename(project_folder)
        
        if folder_name in metadata:
            project_info = metadata[folder_name]
            project_info['file_count'] = project_info.get('file_count', 0) + 1
            project_info['last_updated'] = datetime.now().isoformat()
            
            # Track domains and languages
            if domain not in project_info.get('domains', []):
                project_info.setdefault('domains', []).append(domain)
            
            if language and language not in project_info.get('languages', []):
                project_info.setdefault('languages', []).append(language)
            
            self._save_projects_metadata(metadata)
    
    def list_projects(self) -> List[Dict[str, Any]]:
        """List all projects with their metadata."""
        
        metadata = self._load_projects_metadata()
        projects = []
        
        for folder_name, info in metadata.items():
            project_info = {
                'name': folder_name,
                'objective': info.get('objective', 'Unknown'),
                'file_count': info.get('file_count', 0),
                'domains': info.get('domains', []),
                'languages': info.get('languages', []),
                'created_at': info.get('created_at', 'Unknown'),
                'last_updated': info.get('last_updated', 'Unknown'),
                'folder_path': info.get('folder_path', '')
            }
            projects.append(project_info)
        
        # Sort by last updated
        projects.sort(key=lambda x: x['last_updated'], reverse=True)
        return projects