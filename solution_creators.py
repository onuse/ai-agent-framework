import ollama
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

class BaseSolutionCreator(ABC):
    """Base class for domain-specific solution creators."""
    
    def __init__(self, model_name: str = "llama3.1:8b"):
        self.model_name = model_name
    
    @abstractmethod
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        """Create a domain-specific prompt for the task."""
        pass
    
    @abstractmethod
    def get_execution_type(self) -> str:
        """Return the execution type for this domain."""
        pass
    
    def generate_solution(self, task: Dict[str, Any], context: str = "") -> Dict[str, Any]:
        """Generate solution using domain-specific prompting."""
        
        prompt = self.create_solution_prompt(task, context)
        
        try:
            response = ollama.chat(
                model=self.model_name,
                messages=[{"role": "user", "content": prompt}]
            )
            
            content = response['message']['content']
            return self._extract_solution(content)
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Error generating solution: {str(e)}'
            }
    
    def _extract_solution(self, content: str) -> Dict[str, Any]:
        """Extract solution from LLM response."""
        
        explanation = ""
        solution = ""
        
        if "EXPLANATION:" in content:
            parts = content.split("EXPLANATION:", 1)
            if len(parts) > 1:
                remaining = parts[1]
                if any(marker in remaining for marker in ["CODE:", "CONTENT:", "SOLUTION:"]):
                    for marker in ["CODE:", "CONTENT:", "SOLUTION:"]:
                        if marker in remaining:
                            exp_sol = remaining.split(marker, 1)
                            explanation = exp_sol[0].strip()
                            solution_section = exp_sol[1].strip()
                            break
                else:
                    explanation = remaining.strip()
                    solution_section = ""
            else:
                solution_section = content
        else:
            solution_section = content
        
        # Extract solution from markdown blocks
        solution = self._extract_from_markdown(solution_section)
        
        if not solution:
            solution = solution_section.strip()
        
        if not solution:
            return {
                'success': False,
                'error': 'No solution content generated by LLM'
            }
        
        return {
            'success': True,
            'solution': solution,
            'explanation': explanation
        }
    
    def _extract_from_markdown(self, content: str) -> str:
        """Extract content from markdown code blocks."""
        
        # Try different markdown patterns
        patterns = ["```python", "```javascript", "```", "```text", "```markdown"]
        
        for pattern in patterns:
            if pattern in content:
                start_idx = content.find(pattern) + len(pattern)
                end_idx = content.find("```", start_idx)
                if end_idx != -1:
                    return content[start_idx:end_idx].strip()
                else:
                    return content[start_idx:].strip()
        
        return ""

class CodeSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for software development tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior software engineer with expertise in clean, maintainable code.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Working code')}

{context}

Generate production-ready Python code that:
1. Follows best practices and PEP 8 style guidelines
2. Includes comprehensive error handling
3. Has clear, informative comments
4. Is modular and reusable
5. Includes input validation where appropriate
6. Prints progress/status information

Focus on:
- Clean architecture and separation of concerns
- Proper exception handling
- Efficient algorithms and data structures
- Clear variable and function names
- Comprehensive docstrings

Format your response as:
EXPLANATION:
[Brief explanation of your technical approach and design decisions]

CODE:
```python
[Your complete, production-ready Python code]
```

Ensure the code is immediately executable and handles edge cases gracefully."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "subprocess"

class CreativeSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for creative writing tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a professional creative writer with expertise in engaging storytelling.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Creative content')}

{context}

Create compelling written content that:
1. Engages the reader from the first sentence
2. Maintains consistent tone and style
3. Develops characters with depth and authenticity
4. Uses vivid, descriptive language
5. Follows proper narrative structure
6. Shows rather than tells

Focus on:
- Strong opening hooks and satisfying conclusions
- Authentic dialogue and character voice
- Rich sensory details and imagery
- Proper pacing and tension
- Emotional resonance with readers
- Genre-appropriate conventions

Format your response as:
EXPLANATION:
[Brief explanation of your creative approach, themes, and narrative choices]

CONTENT:
```text
[Your complete creative content]
```

Aim for professional publication quality with attention to craft and reader engagement."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "text_processing"

class DataSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for data analysis tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior data scientist with expertise in statistical analysis and visualization.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Data analysis')}

{context}

Generate comprehensive data analysis code that:
1. Uses pandas, numpy, and matplotlib/seaborn effectively
2. Includes proper data cleaning and validation
3. Performs relevant statistical analysis
4. Creates clear, informative visualizations
5. Provides meaningful insights and conclusions
6. Documents methodology and assumptions

Focus on:
- Robust data preprocessing and cleaning
- Appropriate statistical methods
- Clear, publication-ready visualizations
- Meaningful insights and actionable recommendations
- Proper handling of missing data and outliers
- Statistical significance testing where relevant

Format your response as:
EXPLANATION:
[Brief explanation of your analytical approach and methodology]

CODE:
```python
[Your complete data analysis code with visualizations]
```

Ensure the analysis is statistically sound and provides clear business value."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "data_processing"

class UISolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for user interface tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior UI/UX developer with expertise in creating intuitive user interfaces.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'User interface')}

{context}

Create user-friendly interface code that:
1. Follows UI/UX best practices and conventions
2. Is accessible and intuitive to use
3. Has responsive design principles
4. Includes proper event handling
5. Provides clear user feedback
6. Uses consistent visual design

Focus on:
- Intuitive layout and navigation
- Clear visual hierarchy and typography
- Accessible design (keyboard navigation, screen readers)
- Consistent interaction patterns
- Helpful error messages and validation
- Professional visual appearance

For tkinter applications, use grid layout consistently and include:
- Proper widget sizing and padding
- Keyboard shortcuts and accessibility
- Clear labels and instructions
- Professional color scheme and fonts

Format your response as:
EXPLANATION:
[Brief explanation of your UI/UX design decisions and user experience approach]

CODE:
```python
[Your complete UI code with proper event handling]
```

Ensure the interface is professional, accessible, and provides excellent user experience."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "gui_application"

class ResearchSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for research and information gathering tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a professional researcher with expertise in information synthesis and analysis.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Research document')}

{context}

Create comprehensive research content that:
1. Presents information clearly and objectively
2. Uses proper academic or professional structure
3. Includes relevant examples and case studies
4. Synthesizes information from multiple perspectives
5. Provides actionable insights and conclusions
6. Uses appropriate citations and references

Focus on:
- Logical organization and clear structure
- Objective analysis with supporting evidence
- Balanced presentation of different viewpoints
- Clear executive summary and key findings
- Actionable recommendations
- Professional formatting and presentation

Format your response as:
EXPLANATION:
[Brief explanation of your research methodology and approach]

CONTENT:
```markdown
[Your complete research document in markdown format]
```

Ensure the research is thorough, well-organized, and provides clear value to stakeholders."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "document_generation"

class GameSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for game development tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior game developer with expertise in creating engaging interactive experiences.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Game code')}

{context}

Create engaging game code that:
1. Implements smooth, responsive gameplay mechanics
2. Uses efficient algorithms for real-time performance
3. Includes proper game state management
4. Has intuitive controls and user feedback
5. Follows game development best practices
6. Is modular and easily extensible

Focus on:
- Smooth frame rates and responsive controls
- Clear game mechanics and objectives
- Progressive difficulty and player engagement
- Efficient resource management
- Clean separation of game logic and rendering
- Proper collision detection and physics

For Python games, prefer pygame or tkinter with:
- Consistent frame timing
- Efficient rendering loops
- Proper event handling
- Clean game state architecture

Format your response as:
EXPLANATION:
[Brief explanation of your game design and technical implementation approach]

CODE:
```python
[Your complete game code with proper game loop and mechanics]
```

Ensure the game is playable, engaging, and demonstrates solid game development principles."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "game_application"

class SolutionCreatorFactory:
    """Factory for creating domain-specific solution creators."""
    
    @staticmethod
    def create_solution_creator(domain: str, model_name: str = "llama3.1:8b") -> BaseSolutionCreator:
        """Create appropriate solution creator based on domain."""
        
        creators = {
            'code': CodeSolutionCreator,
            'creative': CreativeSolutionCreator,
            'data': DataSolutionCreator,
            'ui': UISolutionCreator,
            'research': ResearchSolutionCreator,
            'game': GameSolutionCreator
        }
        
        creator_class = creators.get(domain, CodeSolutionCreator)
        return creator_class(model_name)