import ollama
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

class BaseSolutionCreator(ABC):
    """Base class for domain-specific solution creators."""
    
    def __init__(self, model_name: str = "llama3.1:8b"):
        self.model_name = model_name
    
    @abstractmethod
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        """Create a domain-specific prompt for the task."""
        pass
    
    @abstractmethod
    def get_execution_type(self) -> str:
        """Return the execution type for this domain."""
        pass
    
    def generate_solution(self, task: Dict[str, Any], context: str = "") -> Dict[str, Any]:
        """Generate solution using domain-specific prompting."""
        
        prompt = self.create_solution_prompt(task, context)
        
        try:
            response = ollama.chat(
                model=self.model_name,
                messages=[{"role": "user", "content": prompt}]
            )
            
            content = response['message']['content']
            return self._extract_solution(content)
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Error generating solution: {str(e)}'
            }
    
    def _extract_solution(self, content: str) -> Dict[str, Any]:
        """Extract solution from LLM response."""
        
        explanation = ""
        solution = ""
        
        if "EXPLANATION:" in content:
            parts = content.split("EXPLANATION:", 1)
            if len(parts) > 1:
                remaining = parts[1]
                if any(marker in remaining for marker in ["CODE:", "CONTENT:", "SOLUTION:"]):
                    for marker in ["CODE:", "CONTENT:", "SOLUTION:"]:
                        if marker in remaining:
                            exp_sol = remaining.split(marker, 1)
                            explanation = exp_sol[0].strip()
                            solution_section = exp_sol[1].strip()
                            break
                else:
                    explanation = remaining.strip()
                    solution_section = ""
            else:
                solution_section = content
        else:
            solution_section = content
        
        # Extract solution from markdown blocks
        solution = self._extract_from_markdown(solution_section)
        
        if not solution:
            solution = solution_section.strip()
        
        if not solution:
            return {
                'success': False,
                'error': 'No solution content generated by LLM'
            }
        
        return {
            'success': True,
            'solution': solution,
            'explanation': explanation
        }
    
    def _extract_from_markdown(self, content: str) -> str:
        """Extract content from markdown code blocks."""
        
        # Try different markdown patterns
        patterns = ["```python", "```javascript", "```", "```text", "```markdown"]
        
        for pattern in patterns:
            if pattern in content:
                start_idx = content.find(pattern) + len(pattern)
                end_idx = content.find("```", start_idx)
                if end_idx != -1:
                    return content[start_idx:end_idx].strip()
                else:
                    return content[start_idx:].strip()
        
        return ""

class CodeSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for software development tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior software engineer with expertise in clean, maintainable code.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Working code')}

{context}

CRITICAL REQUIREMENTS:
1. Create code that runs and exits cleanly (no infinite loops, no input() calls)
2. Use print() statements for output instead of requiring user interaction
3. Include proper error handling
4. Make the code self-contained and executable

Generate production-ready Python code that:
1. Follows best practices and PEP 8 style guidelines
2. Includes comprehensive error handling
3. Has clear, informative comments
4. Is modular and reusable
5. Prints progress/status information
6. RUNS AND EXITS CLEANLY (no waiting for input, no infinite loops)

Focus on:
- Clean architecture and separation of concerns
- Proper exception handling
- Efficient algorithms and data structures
- Clear variable and function names
- Comprehensive docstrings
- Code that demonstrates functionality and then exits

Format your response as:
EXPLANATION:
[Brief explanation of your technical approach and design decisions]

CODE:
```python
[Your complete, production-ready Python code that runs and exits cleanly]
```

IMPORTANT: The code must be immediately executable and demonstrate the functionality without requiring user input or running indefinitely."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "subprocess"

class CreativeSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for creative writing tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a professional creative writer with expertise in engaging storytelling.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Creative content')}

{context}

Create compelling written content that:
1. Engages the reader from the first sentence
2. Maintains consistent tone and style
3. Develops characters with depth and authenticity
4. Uses vivid, descriptive language
5. Follows proper narrative structure
6. Shows rather than tells

Focus on:
- Strong opening hooks and satisfying conclusions
- Authentic dialogue and character voice
- Rich sensory details and imagery
- Proper pacing and tension
- Emotional resonance with readers
- Genre-appropriate conventions

Format your response as:
EXPLANATION:
[Brief explanation of your creative approach, themes, and narrative choices]

CONTENT:
```text
[Your complete creative content]
```

Aim for professional publication quality with attention to craft and reader engagement."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "text_processing"

class DataSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for data analysis tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior data scientist with expertise in statistical analysis and visualization.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Data analysis')}

{context}

CRITICAL REQUIREMENTS:
1. Create code that runs with sample/mock data (no external file dependencies)
2. Use print() statements to show results
3. Code should run and exit cleanly

Generate comprehensive data analysis code that:
1. Uses pandas, numpy, and matplotlib/seaborn effectively
2. Creates sample data if no data is provided
3. Performs relevant statistical analysis
4. Creates clear, informative visualizations
5. Provides meaningful insights and conclusions
6. Documents methodology and assumptions

Focus on:
- Robust data preprocessing and cleaning
- Appropriate statistical methods
- Clear, publication-ready visualizations
- Meaningful insights and actionable recommendations
- Proper handling of missing data and outliers
- Statistical significance testing where relevant

Format your response as:
EXPLANATION:
[Brief explanation of your analytical approach and methodology]

CODE:
```python
[Your complete data analysis code with sample data and visualizations]
```

Ensure the analysis uses sample data and runs completely without external dependencies."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "data_processing"

class UISolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for user interface tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior UI/UX developer with expertise in creating intuitive user interfaces.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'User interface')}

{context}

Create user-friendly interface code that:
1. Follows UI/UX best practices and conventions
2. Is accessible and intuitive to use
3. Has responsive design principles
4. Includes proper event handling
5. Provides clear user feedback
6. Uses consistent visual design

Focus on:
- Intuitive layout and navigation
- Clear visual hierarchy and typography
- Accessible design (keyboard navigation, screen readers)
- Consistent interaction patterns
- Helpful error messages and validation
- Professional visual appearance

For tkinter applications, use grid layout consistently and include:
- Proper widget sizing and padding
- Keyboard shortcuts and accessibility
- Clear labels and instructions
- Professional color scheme and fonts

Format your response as:
EXPLANATION:
[Brief explanation of your UI/UX design decisions and user experience approach]

CODE:
```python
[Your complete UI code with proper event handling]
```

Ensure the interface is professional, accessible, and provides excellent user experience."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "gui_application"

class ResearchSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for research and information gathering tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a professional researcher with expertise in information synthesis and analysis.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Research document')}

{context}

Create comprehensive research content that:
1. Presents information clearly and objectively
2. Uses proper academic or professional structure
3. Includes relevant examples and case studies
4. Synthesizes information from multiple perspectives
5. Provides actionable insights and conclusions
6. Uses appropriate citations and references

Focus on:
- Logical organization and clear structure
- Objective analysis with supporting evidence
- Balanced presentation of different viewpoints
- Clear executive summary and key findings
- Actionable recommendations
- Professional formatting and presentation

Format your response as:
EXPLANATION:
[Brief explanation of your research methodology and approach]

CONTENT:
```markdown
[Your complete research document in markdown format]
```

Ensure the research is thorough, well-organized, and provides clear value to stakeholders."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "document_generation"

class GameSolutionCreator(BaseSolutionCreator):
    """Specialized solution creator for game development tasks."""
    
    def create_solution_prompt(self, task: Dict[str, Any], context: str = "") -> str:
        task_data = task['subtask_data']
        
        base_prompt = f"""You are a senior game developer with expertise in creating engaging interactive experiences.

TASK: {task['title']}
DESCRIPTION: {task['description']}
DELIVERABLE: {task_data.get('deliverable', 'Game code')}

{context}

CRITICAL REQUIREMENTS:
1. For demonstration purposes, create a game that runs briefly and then exits
2. Include a demo mode that shows gameplay without requiring user input
3. Use print() statements to describe what's happening

Create engaging game code that:
1. Implements smooth, responsive gameplay mechanics
2. Uses efficient algorithms for real-time performance
3. Includes proper game state management
4. Has intuitive controls and user feedback
5. Follows game development best practices
6. Is modular and easily extensible

Focus on:
- Smooth frame rates and responsive controls
- Clear game mechanics and objectives
- Progressive difficulty and player engagement
- Efficient resource management
- Clean separation of game logic and rendering
- Proper collision detection and physics

For Python games, prefer pygame or tkinter with:
- Consistent frame timing
- Efficient rendering loops
- Proper event handling
- Clean game state architecture

Format your response as:
EXPLANATION:
[Brief explanation of your game design and technical implementation approach]

CODE:
```python
[Your complete game code with demo mode that runs and exits cleanly]
```

Ensure the game demonstrates functionality and then exits for testing purposes."""
        
        return base_prompt
    
    def get_execution_type(self) -> str:
        return "game_application"

class SolutionCreatorFactory:
    """Factory for creating domain-specific solution creators."""
    
    @staticmethod
    def create_solution_creator(domain: str, model_name: str = "llama3.1:8b") -> BaseSolutionCreator:
        """Create appropriate solution creator based on domain."""
        
        creators = {
            'code': CodeSolutionCreator,
            'creative': CreativeSolutionCreator,
            'data': DataSolutionCreator,
            'ui': UISolutionCreator,
            'research': ResearchSolutionCreator,
            'game': GameSolutionCreator
        }
        
        creator_class = creators.get(domain, CodeSolutionCreator)
        return creator_class(model_name)